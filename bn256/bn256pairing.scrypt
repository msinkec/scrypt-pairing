import "bn256.scrypt";


library BN256Pairing {

    static function miller(TwistPoint q, CurvePoint p) : FQ12 {
        FQ12 ret = {
            {[0, 0], [0, 0], [0, 0]},
            {[0, 0], [0, 0], [0, 1]}
        };

        TwistPoint aAffine = BN256.makeAffineTwistPoint(q);

        return ret;
    }

    static function finalExponentiation(FQ12 in) : FQ12 {
        FQ12 t1 = {
            BN256.negFQ6(in.x),
            in.y
        }; 

        FQ12 inv = BN256.inverseFQ12(in);
        t1 = BN256.mulFQ12(t1, inv);

        FQ12 t2 = BN256.frobeniusP2FQ12(t1);
        t1 = BN256.mulFQ12(t1, t2);

        FQ12 fp = BN256.frobeniusFQ12(t1);
        FQ12 fp2 = BN256.frobeniusP2FQ12(t1);
        FQ12 fp3 = BN256.frobeniusFQ12(fp2);

        FQ12 fu = BN256.expFQ12_u(t1);
        FQ12 fu2 = BN256.expFQ12_u(fu);
        FQ12 fu3 = BN256.expFQ12_u(fu2);

        FQ12 y3 = BN256.frobeniusFQ12(fu);
        FQ12 fu2p = BN256.frobeniusFQ12(fu2);
        FQ12 fu3p = BN256.frobeniusFQ12(fu3);
        FQ12 y2 = BN256.frobeniusP2FQ12(fu2);

        FQ12 y0 = BN256.mulFQ12(fp, fp2);
        y0 = BN256.mulFQ12(y0, fp3);

        FQ12 y1 = BN256.conjugateFQ12(t1);
        FQ12 y5 = BN256.conjugateFQ12(fu2);
        y3 = BN256.conjugateFQ12(y3);
        FQ12 y4 = BN256.mulFQ12(fu ,fu2p);
        y4 = BN256.conjugateFQ12(y4);

        FQ12 y6 = BN256.mulFQ12(fu3, fu3p);
        y6 = BN256.conjugateFQ12(y6);

        FQ12 t0 = BN256.squareFQ12(y6);
        t0 = BN256.mulFQ12(t0, y4);
        t0 = BN256.mulFQ12(t0, y5);
        t1 = BN256.mulFQ12(y3, y5);
        t1 = BN256.mulFQ12(t1, t0);
        t0 = BN256.mulFQ12(t0, y2);
        t1 = BN256.squareFQ12(t1);
        t1 = BN256.mulFQ12(t1, t0);
        t1 = BN256.squareFQ12(t1);
        t0 = BN256.mulFQ12(t1, y1);
        t1 = BN256.mulFQ12(t1, y0);
        t0 = BN256.squareFQ12(t0);
        t0 = BN256.mulFQ12(t0, t1);

        return t0;
    }

    static function pair(CurvePoint g1, TwistPoint g2) : FQ12 {
        FQ12 e = miller(g2, g1);

        return e;
    //e := miller(g2, g1, pool)
    //ret := finalExponentiation(e, pool)
    //e.Put(pool)

    //if a.IsInfinity() || b.IsInfinity() {
    //    ret.SetOne()
    //}
    //return ret
    }

}

