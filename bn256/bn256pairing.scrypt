import "bn256.scrypt";


library BN256Pairing {

    static function miller(TwistPoint q, CurvePoint p) : FQ12 {
        FQ12 ret = {
            {[0, 0], [0, 0], [0, 0]},
            {[0, 0], [0, 0], [0, 1]}
        };

        TwistPoint aAffine = BN256.makeAffine(q);

        return ret;
    }

    static function finalExponentiation(FQ12 in) : FQ12 {
        FQ12 t1 = {
            BN256.negateFQ6(in.x),
            in.y
        }; 

        FQ12 inv = BN256.inverseFQ12(in);
        t1 = BN256.mulFQ12(t1, inv);

        FQ12 t2 = BN256.frobeniusP2FQ12(t1);
        t1 = BN256.mulFQ12(t1, t2);

        FQ12 fp = BN256.frobeniusFQ12(t1);
        FQ12 fp2 = BN256.frobeniusP2FQ12(t1);
        FQ12 fp3 = BN256.frobeniusFQ12(fp2);

        FQ12 fu = exp


    //fu, fu2, fu3 := newGFp12(pool), newGFp12(pool), newGFp12(pool)
    //fu.Exp(t1, u, pool)
    //fu2.Exp(fu, u, pool)
    //fu3.Exp(fu2, u, pool)

    //y3 := newGFp12(pool).Frobenius(fu, pool)
    //fu2p := newGFp12(pool).Frobenius(fu2, pool)
    //fu3p := newGFp12(pool).Frobenius(fu3, pool)
    //y2 := newGFp12(pool).FrobeniusP2(fu2, pool)

    //y0 := newGFp12(pool)
    //y0.Mul(fp, fp2, pool)
    //y0.Mul(y0, fp3, pool)

    //y1, y4, y5 := newGFp12(pool), newGFp12(pool), newGFp12(pool)
    //y1.Conjugate(t1)
    //y5.Conjugate(fu2)
    //y3.Conjugate(y3)
    //y4.Mul(fu, fu2p, pool)
    //y4.Conjugate(y4)

    //y6 := newGFp12(pool)
    //y6.Mul(fu3, fu3p, pool)
    //y6.Conjugate(y6)

    //t0 := newGFp12(pool)
    //t0.Square(y6, pool)
    //t0.Mul(t0, y4, pool)
    //t0.Mul(t0, y5, pool)
    //t1.Mul(y3, y5, pool)
    //t1.Mul(t1, t0, pool)
    //t0.Mul(t0, y2, pool)
    //t1.Square(t1, pool)
    //t1.Mul(t1, t0, pool)
    //t1.Square(t1, pool)
    //t0.Mul(t1, y1, pool)
    //t1.Mul(t1, y0, pool)
    //t0.Square(t0, pool)
    //t0.Mul(t0, t1, pool)

    }

    static function pair(CurvePoint g1, TwistPoint g2) : FQ12 {
        FQ12 e = miller(g2, g1);

        return e;
    //e := miller(g2, g1, pool)
    //ret := finalExponentiation(e, pool)
    //e.Put(pool)

    //if a.IsInfinity() || b.IsInfinity() {
    //    ret.SetOne()
    //}
    //return ret
    }

}

